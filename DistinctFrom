[33mcommit f7ab708f0e7e3c48b9e73120924f3b09be6bb285[m[33m ([m[1;36mHEAD -> [m[1;32mzongyu/bitwise_operation[m[33m)[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Sun May 29 22:02:11 2022 +0800

    last commit

[1mdiff --git a/src/expr/src/expr/expr_binary_nonnull.rs b/src/expr/src/expr/expr_binary_nonnull.rs[m
[1mindex 17e1c1c53..8083c4859 100644[m
[1m--- a/src/expr/src/expr/expr_binary_nonnull.rs[m
[1m+++ b/src/expr/src/expr/expr_binary_nonnull.rs[m
[36m@@ -392,7 +392,7 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         }[m
[31m-        Type::PgBitwiseShiftRight =>{[m
[32m+[m[32m        Type::PgBitwiseShiftRight => {[m
             gen_binary_expr_shift! {[m
                 gen_atm_impl,[m
                 l, r, ret,[m
[36m@@ -410,7 +410,7 @@[m [mpub fn new_binary_expr([m
                 {[m
                 },[m
             }[m
[31m-        },[m
[32m+[m[32m        }[m
         Type::BitwiseOr => {[m
             gen_binary_expr_shift! {[m
                 gen_atm_impl,[m
[36m@@ -419,7 +419,7 @@[m [mpub fn new_binary_expr([m
                 {[m
                 },[m
             }[m
[31m-        },[m
[32m+[m[32m        }[m
         Type::BitwiseXor => {[m
             gen_binary_expr_shift! {[m
                 gen_atm_impl,[m
[36m@@ -428,7 +428,7 @@[m [mpub fn new_binary_expr([m
                 {[m
                 },[m
             }[m
[31m-        },[m
[32m+[m[32m        }[m
         Type::Extract => build_extract_expr(ret, l, r),[m
         Type::RoundDigit => Box::new([m
             BinaryExpression::<DecimalArray, I32Array, DecimalArray, _>::new([m
[36m@@ -442,7 +442,7 @@[m [mpub fn new_binary_expr([m
             l, r, ret, position,[m
         )),[m
         Type::TumbleStart => new_tumble_start(l, r, ret),[m
[31m-        [m
[32m+[m
         tp => {[m
             unimplemented!([m
                 "The expression {:?} using vectorized expression framework is not supported yet!",[m
[1mdiff --git a/src/expr/src/expr/expr_unary.rs b/src/expr/src/expr/expr_unary.rs[m
[1mindex 8bfc92ec8..281e1d88e 100644[m
[1m--- a/src/expr/src/expr/expr_unary.rs[m
[1m+++ b/src/expr/src/expr/expr_unary.rs[m
[36m@@ -25,6 +25,7 @@[m [muse crate::expr::template::UnaryNullableExpression;[m
 use crate::expr::BoxedExpression;[m
 use crate::vector_op::arithmetic_op::{decimal_abs, general_abs, general_neg};[m
 use crate::vector_op::ascii::ascii;[m
[32m+[m[32muse crate::vector_op::bitwise_op::general_bitnot;[m
 use crate::vector_op::cast::*;[m
 use crate::vector_op::cmp::{is_false, is_not_false, is_not_true, is_true};[m
 use crate::vector_op::conjunction;[m
[36m@@ -34,7 +35,6 @@[m [muse crate::vector_op::ltrim::ltrim;[m
 use crate::vector_op::rtrim::rtrim;[m
 use crate::vector_op::trim::trim;[m
 use crate::vector_op::upper::upper;[m
[31m-use crate::vector_op::bitwise_op::general_bitnot;[m
 [m
 /// This macro helps to create cast expression.[m
 /// It receives all the combinations of `gen_cast` and generates corresponding match cases[m
[36m@@ -281,7 +281,7 @@[m [mpub fn new_unary_expr([m
             }[m
         }[m
         (ProstType::BitwiseNot, _, _) => {[m
[31m-            gen_unary_impl!{ [m
[32m+[m[32m            gen_unary_impl! {[m
                 [ "Bitwisenot", child_expr, return_type],[m
                 { int16, int16, general_bitnot },[m
                 { int32, int32, general_bitnot },[m
[1mdiff --git a/src/expr/src/expr/mod.rs b/src/expr/src/expr/mod.rs[m
[1mindex 22ee1c948..709cf8687 100644[m
[1m--- a/src/expr/src/expr/mod.rs[m
[1m+++ b/src/expr/src/expr/mod.rs[m
[36m@@ -79,7 +79,8 @@[m [mpub fn build_from_prost(prost: &ExprNode) -> Result<BoxedExpression> {[m
         | IsNotNull | Neg | Ascii | Abs | BitwiseNot => build_unary_expr_prost(prost),[m
         Equal | NotEqual | LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Add[m
         | Subtract | Multiply | Divide | Modulus | Extract | RoundDigit | TumbleStart[m
[31m-        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd | BitwiseOr | BitwiseXor => build_binary_expr_prost(prost),[m
[32m+[m[32m        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd | BitwiseOr[m
[32m+[m[32m        | BitwiseXor => build_binary_expr_prost(prost),[m
         And | Or => build_nullable_binary_expr_prost(prost),[m
         Coalesce => CoalesceExpression::try_from(prost).map(|d| Box::new(d) as BoxedExpression),[m
         Substr => build_substr_expr(prost),[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex d6c521395..e1e8a5e4c 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -1,113 +1,109 @@[m
[31m-// Copyright 2022 Singularity Data[m
[31m-//[m
[31m-// Licensed under the Apache License, Version 2.0 (the "License");[m
[31m-// you may not use this file except in compliance with the License.[m
[31m-// You may obtain a copy of the License at[m
[31m-//[m
[31m-// http://www.apache.org/licenses/LICENSE-2.0[m
[31m-//[m
[31m-// Unless required by applicable law or agreed to in writing, software[m
[31m-// distributed under the License is distributed on an "AS IS" BASIS,[m
[31m-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[31m-// See the License for the specific language governing permissions and[m
[31m-// limitations under the License.[m
[31m-use std::any::type_name;[m
[31m-use std::convert::TryInto;[m
[31m-use std::fmt::Debug;[m
[31m-use std::ops::{BitAnd, BitOr, BitXor, Not};[m
[31m-[m
[31m-use num_traits::{CheckedShl,CheckedShr};[m
[31m-use risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange};[m
[31m-use risingwave_common::error::{Result, RwError};[m
[31m-[m
[31m-[m
[31m-use crate::vector_op::arithmetic_op::general_atm;[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_shl<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<u32> + Debug,[m
[31m-    T3: CheckedShl,[m
[31m-{[m
[31m-    general_shift(l, r, |a, b| match a.checked_shl(b) {[m
[31m-        Some(c) => Ok(c),[m
[31m-        None => Err(RwError::from(NumericValueOutOfRange)),[m
[31m-    })[m
[31m-}[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_shr<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<u32> + Debug,[m
[31m-    T3: CheckedShr,[m
[31m-{[m
[31m-    general_shift(l, r, |a, b| match a.checked_shr(b) {[m
[31m-        Some(c) => Ok(c),[m
[31m-        None => Err(RwError::from(NumericValueOutOfRange)),[m
[31m-    })[m
[31m-}[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_shift<T1, T2, T3, F>(l: T1, r: T2, atm: F) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<u32> + Debug,[m
[31m-    F: FnOnce(T3, u32) -> Result<T3>,[m
[31m-{[m
[31m-    // TODO: We need to improve the error message[m
[31m-    let l: T3 = l.try_into().map_err(|_| {[m
[31m-        RwError::from(InternalError(format!([m
[31m-            "Can't convert {} to {}",[m
[31m-            type_name::<T1>(),[m
[31m-            type_name::<T3>()[m
[31m-        )))[m
[31m-    })?;[m
[31m-    let r: u32 = r.try_into().map_err(|_| {[m
[31m-        RwError::from(InternalError(format!([m
[31m-            "Can't convert {} to {}",[m
[31m-            type_name::<T2>(),[m
[31m-            type_name::<u32>()[m
[31m-        )))[m
[31m-    })?;[m
[31m-    atm(l, r)[m
[31m-}[m
[31m-[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_bitand<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<T3> + Debug,[m
[31m-    T3: BitAnd<Output = T3>,[m
[31m-{[m
[31m-    general_atm(l, r,  |a, b| Ok( a.bitand(b)) )[m
[31m-}[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_bitor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<T3> + Debug,[m
[31m-    T3: BitOr<Output = T3>,[m
[31m-{[m
[31m-    general_atm(l, r,  |a, b| Ok( a.bitor(b)) )[m
[31m-}[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_bitxor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-where[m
[31m-    T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<T3> + Debug,[m
[31m-    T3: BitXor<Output = T3>,[m
[31m-{[m
[31m-    general_atm(l, r,  |a, b| Ok( a.bitxor(b)) )[m
[31m-}[m
[31m-[m
[31m-[m
[31m-#[inline(always)][m
[31m-pub fn general_bitnot<T1: Not<Output = T1>>(expr: T1) -> Result<T1> {[m
[31m-    Ok(expr.not())[m
[31m-}[m
[31m-[m
[32m+[m[32m// Copyright 2022 Singularity Data[m
[32m+[m[32m//[m
[32m+[m[32m// Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m// you may not use this file except in compliance with the License.[m
[32m+[m[32m// You may obtain a copy of the License at[m
[32m+[m[32m//[m
[32m+[m[32m// http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m//[m
[32m+[m[32m// Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m// distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m// See the License for the specific language governing permissions and[m
[32m+[m[32m// limitations under the License.[m
[32m+[m[32muse std::any::type_name;[m
[32m+[m[32muse std::convert::TryInto;[m
[32m+[m[32muse std::fmt::Debug;[m
[32m+[m[32muse std::ops::{BitAnd, BitOr, BitXor, Not};[m
[32m+[m
[32m+[m[32muse num_traits::{CheckedShl, CheckedShr};[m
[32m+[m[32muse risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange};[m
[32m+[m[32muse risingwave_common::error::{Result, RwError};[m
[32m+[m
[32m+[m[32muse crate::vector_op::arithmetic_op::general_atm;[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_shl<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m
[32m+[m[32m    T3: CheckedShl,[m
[32m+[m[32m{[m
[32m+[m[32m    general_shift(l, r, |a, b| match a.checked_shl(b) {[m
[32m+[m[32m        Some(c) => Ok(c),[m
[32m+[m[32m        None => Err(RwError::from(NumericValueOutOfRange)),[m
[32m+[m[32m    })[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_shr<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m
[32m+[m[32m    T3: CheckedShr,[m
[32m+[m[32m{[m
[32m+[m[32m    general_shift(l, r, |a, b| match a.checked_shr(b) {[m
[32m+[m[32m        Some(c) => Ok(c),[m
[32m+[m[32m        None => Err(RwError::from(NumericValueOutOfRange)),[m
[32m+[m[32m    })[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_shift<T1, T2, T3, F>(l: T1, r: T2, atm: F) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m
[32m+[m[32m    F: FnOnce(T3, u32) -> Result<T3>,[m
[32m+[m[32m{[m
[32m+[m[32m    // TODO: We need to improve the error message[m
[32m+[m[32m    let l: T3 = l.try_into().map_err(|_| {[m
[32m+[m[32m        RwError::from(InternalError(format!([m
[32m+[m[32m            "Can't convert {} to {}",[m
[32m+[m[32m            type_name::<T1>(),[m
[32m+[m[32m            type_name::<T3>()[m
[32m+[m[32m        )))[m
[32m+[m[32m    })?;[m
[32m+[m[32m    let r: u32 = r.try_into().map_err(|_| {[m
[32m+[m[32m        RwError::from(InternalError(format!([m
[32m+[m[32m            "Can't convert {} to {}",[m
[32m+[m[32m            type_name::<T2>(),[m
[32m+[m[32m            type_name::<u32>()[m
[32m+[m[32m        )))[m
[32m+[m[32m    })?;[m
[32m+[m[32m    atm(l, r)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_bitand<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m
[32m+[m[32m    T3: BitAnd<Output = T3>,[m
[32m+[m[32m{[m
[32m+[m[32m    general_atm(l, r, |a, b| Ok(a.bitand(b)))[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_bitor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m
[32m+[m[32m    T3: BitOr<Output = T3>,[m
[32m+[m[32m{[m
[32m+[m[32m    general_atm(l, r, |a, b| Ok(a.bitor(b)))[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_bitxor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[32m+[m[32mwhere[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m
[32m+[m[32m    T3: BitXor<Output = T3>,[m
[32m+[m[32m{[m
[32m+[m[32m    general_atm(l, r, |a, b| Ok(a.bitxor(b)))[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#[inline(always)][m
[32m+[m[32mpub fn general_bitnot<T1: Not<Output = T1>>(expr: T1) -> Result<T1> {[m
[32m+[m[32m    Ok(expr.not())[m
[32m+[m[32m}[m
[1mdiff --git a/src/expr/src/vector_op/tests.rs b/src/expr/src/vector_op/tests.rs[m
[1mindex 4099b387a..d0a7ba90f 100644[m
[1m--- a/src/expr/src/vector_op/tests.rs[m
[1m+++ b/src/expr/src/vector_op/tests.rs[m
[36m@@ -140,33 +140,31 @@[m [mfn test_arithmetic() {[m
 #[test][m
 fn test_bitwise() {[m
     // check the boundary[m
[31m-    [m
[31m-    assert_eq!([m
[31m-        general_shl::<i32, i32, i64>(1i32, 0i32).unwrap(),[m
[31m-        1i64);[m
[32m+[m
[32m+[m[32m    assert_eq!(general_shl::<i32, i32, i64>(1i32, 0i32).unwrap(), 1i64);[m
     assert_eq!([m
         general_shl::<i32, i32, i64>(1i32, 31i32).unwrap(),[m
[31m-        2147483648i64);[m
[32m+[m[32m        2147483648i64[m
[32m+[m[32m    );[m
     assert_eq!([m
         general_shr::<i32, i32, i64>(-2147483648i32, 31i32).unwrap(),[m
[31m-        -1i64);[m
[31m-    assert_eq!([m
[31m-        general_shr::<i32,i32,i64>(1i32,0i32),[m
[31m-        Ok(1i64));[m
[32m+[m[32m        -1i64[m
[32m+[m[32m    );[m
[32m+[m[32m    assert_eq!(general_shr::<i32, i32, i64>(1i32, 0i32), Ok(1i64));[m
     // truth table[m
     assert_eq!([m
[31m-        general_bitand::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[31m-        Ok(0b1u64));[m
[31m-    assert_eq!([m
[31m-        general_bitor::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[31m-        Ok(0b0111u64));[m
[32m+[m[32m        general_bitand::<u32, u32, u64>(0b0011u32, 0b0101u32),[m
[32m+[m[32m        Ok(0b1u64)[m
[32m+[m[32m    );[m
     assert_eq!([m
[31m-        general_bitxor::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[31m-        Ok(0b0110u64));[m
[32m+[m[32m        general_bitor::<u32, u32, u64>(0b0011u32, 0b0101u32),[m
[32m+[m[32m        Ok(0b0111u64)[m
[32m+[m[32m    );[m
     assert_eq!([m
[31m-        general_bitnot::<i32>(0b01i32),[m
[31m-        Ok(-2i32));   [m
[31m-[m
[32m+[m[32m        general_bitxor::<u32, u32, u64>(0b0011u32, 0b0101u32),[m
[32m+[m[32m        Ok(0b0110u64)[m
[32m+[m[32m    );[m
[32m+[m[32m    assert_eq!(general_bitnot::<i32>(0b01i32), Ok(-2i32));[m
 }[m
 [m
 #[test][m
[1mdiff --git a/src/frontend/src/binder/expr/binary_op.rs b/src/frontend/src/binder/expr/binary_op.rs[m
[1mindex 575326373..20ea2f7fb 100644[m
[1m--- a/src/frontend/src/binder/expr/binary_op.rs[m
[1m+++ b/src/frontend/src/binder/expr/binary_op.rs[m
[36m@@ -48,7 +48,7 @@[m [mimpl Binder {[m
             BinaryOperator::PGBitwiseXor => ExprType::BitwiseXor,[m
             BinaryOperator::PGBitwiseShiftLeft => ExprType::PgBitwiseShiftLeft,[m
             BinaryOperator::PGBitwiseShiftRight => ExprType::PgBitwiseShiftRight,[m
[31m-            [m
[32m+[m
             _ => return Err(ErrorCode::NotImplemented(format!("{:?}", op), 112.into()).into()),[m
         };[m
         Ok(FunctionCall::new(func_type, vec![bound_left, bound_right])?.into())[m
[1mdiff --git a/src/frontend/src/binder/expr/mod.rs b/src/frontend/src/binder/expr/mod.rs[m
[1mindex eef8d7512..c96df2fd8 100644[m
[1m--- a/src/frontend/src/binder/expr/mod.rs[m
[1m+++ b/src/frontend/src/binder/expr/mod.rs[m
[36m@@ -182,7 +182,7 @@[m [mimpl Binder {[m
             UnaryOperator::PGBitwiseNot => ExprType::BitwiseNot,[m
             UnaryOperator::Plus => {[m
                 return self.rewrite_positive(expr);[m
[31m-            },[m
[32m+[m[32m            }[m
             _ => {[m
                 return Err(ErrorCode::NotImplemented([m
                     format!("unsupported unary expression: {:?}", op),[m
[1mdiff --git a/src/frontend/src/expr/function_call.rs b/src/frontend/src/expr/function_call.rs[m
[1mindex 1b71dfc7c..b746051c4 100644[m
[1m--- a/src/frontend/src/expr/function_call.rs[m
[1m+++ b/src/frontend/src/expr/function_call.rs[m
[36m@@ -73,10 +73,10 @@[m [mimpl std::fmt::Debug for FunctionCall {[m
                 ExprType::And => debug_binary_op(f, "AND", &self.inputs),[m
                 ExprType::Or => debug_binary_op(f, "OR", &self.inputs),[m
                 ExprType::PgBitwiseShiftLeft => debug_binary_op(f, "<<", &self.inputs),[m
[31m-                ExprType::PgBitwiseShiftRight => debug_binary_op(f,">>", &self.inputs),[m
[31m-                ExprType::BitwiseAnd => debug_binary_op(f,"&", &self.inputs),[m
[31m-                ExprType::BitwiseOr => debug_binary_op(f,"|", &self.inputs),[m
[31m-                ExprType::BitwiseXor => debug_binary_op(f,"#", &self.inputs),[m
[32m+[m[32m                ExprType::PgBitwiseShiftRight => debug_binary_op(f, ">>", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseAnd => debug_binary_op(f, "&", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseOr => debug_binary_op(f, "|", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseXor => debug_binary_op(f, "#", &self.inputs),[m
                 _ => {[m
                     let func_name = format!("{:?}", self.func_type);[m
                     let mut builder = f.debug_tuple(&func_name);[m
[1mdiff --git a/src/frontend/src/expr/type_inference.rs b/src/frontend/src/expr/type_inference.rs[m
[1mindex 55a72ed42..030b1e887 100644[m
[1m--- a/src/frontend/src/expr/type_inference.rs[m
[1m+++ b/src/frontend/src/expr/type_inference.rs[m
[36m@@ -245,14 +245,17 @@[m [mfn build_type_derive_map() -> HashMap<FuncSign, DataTypeName> {[m
     // bitwise operator[m
     build_binary_atm_funcs([m
         &mut map,[m
[31m-        &[E::PgBitwiseShiftLeft, E::PgBitwiseShiftRight, E::BitwiseAnd, E::BitwiseOr, E::BitwiseNot, E::BitwiseXor],[m
[31m-        &[T::Int16, T::Int32, T::Int64],[m
[31m-    );[m
[31m-    build_unary_atm_funcs([m
[31m-        &mut map,[m
[31m-        &[E::BitwiseNot],[m
[32m+[m[32m        &[[m
[32m+[m[32m            E::PgBitwiseShiftLeft,[m
[32m+[m[32m            E::PgBitwiseShiftRight,[m
[32m+[m[32m            E::BitwiseAnd,[m
[32m+[m[32m            E::BitwiseOr,[m
[32m+[m[32m            E::BitwiseNot,[m
[32m+[m[32m            E::BitwiseXor,[m
[32m+[m[32m        ],[m
         &[T::Int16, T::Int32, T::Int64],[m
     );[m
[32m+[m[32m    build_unary_atm_funcs(&mut map, &[E::BitwiseNot], &[T::Int16, T::Int32, T::Int64]);[m
     // temporal expressions[m
     for (base, delta) in [[m
         (T::Date, T::Int32),[m
[36m@@ -552,7 +555,7 @@[m [mmod tests {[m
     }[m
 [m
     #[test][m
[31m-    fn test_bitwise(){[m
[32m+[m[32m    fn test_bitwise() {[m
         use DataType::*;[m
         let bitwise_exprs = vec![[m
             ExprType::BitwiseAnd,[m
[36m@@ -571,9 +574,6 @@[m [mmod tests {[m
             (Int64, Int16, Int64),[m
             (Int64, Int32, Int64),[m
             (Int64, Int64, Int64),[m
[31m-           [m
[31m-            [m
[31m-            [m
         ];[m
         for (expr, (t1, t2, tr)) in iproduct!(bitwise_exprs, num_promote_table) {[m
             test_simple_infer_type(expr, vec![t1, t2], tr);[m

[33mcommit 02abad9cfe4b75746248b74fb9bb27d39daacaa4[m[33m ([m[1;31morigin/zongyu/bitwise_operation[m[33m)[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Sat May 28 09:47:44 2022 +0800

    Done Unit testing, and done code e2e test

[1mdiff --git a/e2e_test/batch/types/bitwise.slt b/e2e_test/batch/types/bitwise.slt[m
[1mnew file mode 100644[m
[1mindex 000000000..94558671e[m
[1m--- /dev/null[m
[1m+++ b/e2e_test/batch/types/bitwise.slt[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect 3&5;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m1[m[41m[m
[32m+[m[41m[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect 3|5;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m7[m[41m[m
[32m+[m[41m[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect 3#5;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m6[m[41m[m
[32m+[m[41m[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect 1<<2;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m4[m[41m[m
[32m+[m[41m[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect 4>>2;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m1[m[41m[m
[32m+[m[41m[m
[32m+[m[32mquery T[m[41m[m
[32m+[m[32mselect ~1;[m[41m[m
[32m+[m[32m----[m[41m[m
[32m+[m[32m-2[m
\ No newline at end of file[m
[1mdiff --git a/src/expr/src/expr/expr_binary_nonnull.rs b/src/expr/src/expr/expr_binary_nonnull.rs[m
[1mindex 7fbf5d9e9..17e1c1c53 100644[m
[1m--- a/src/expr/src/expr/expr_binary_nonnull.rs[m
[1m+++ b/src/expr/src/expr/expr_binary_nonnull.rs[m
[36m@@ -429,15 +429,6 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         },[m
[31m-        // Type::Bitwisenot => {[m
[31m-        //     gen_binary_expr_shift! {[m
[31m-        //         gen_atm_impl,[m
[31m-        //         l, ret,[m
[31m-        //         general_bitnot,[m
[31m-        //         {[m
[31m-        //         },[m
[31m-        //     }[m
[31m-        // },[m
         Type::Extract => build_extract_expr(ret, l, r),[m
         Type::RoundDigit => Box::new([m
             BinaryExpression::<DecimalArray, I32Array, DecimalArray, _>::new([m
[1mdiff --git a/src/expr/src/vector_op/tests.rs b/src/expr/src/vector_op/tests.rs[m
[1mindex 92c131bb4..4099b387a 100644[m
[1m--- a/src/expr/src/vector_op/tests.rs[m
[1m+++ b/src/expr/src/vector_op/tests.rs[m
[36m@@ -20,6 +20,7 @@[m [muse risingwave_common::types::{[m
 };[m
 [m
 use crate::vector_op::arithmetic_op::*;[m
[32m+[m[32muse crate::vector_op::bitwise_op::*;[m
 use crate::vector_op::cast::date_to_timestamp;[m
 use crate::vector_op::cmp::*;[m
 use crate::vector_op::conjunction::*;[m
[36m@@ -138,27 +139,33 @@[m [mfn test_arithmetic() {[m
 [m
 #[test][m
 fn test_bitwise() {[m
[31m-    assert!([m
[31m-        general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
[31m-        1);[m
[32m+[m[32m    // check the boundary[m
     [m
[31m-    assert!([m
[31m-        general_shl::<i32, i32, i64>(1, 1).unwrap(),[m
[31m-        2);[m
[31m-    assert!([m
[31m-        general_shl::<i32, i32, i64>(1, 31).unwrap(),[m
[31m-        -2147483648);[m
[31m-[m
[31m-    assert!([m
[31m-        general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
[31m-        1);[m
[31m-    assert!([m
[31m-        general_shl::<i32, i32, i64>(1, 1).unwrap(),[m
[31m-        2);[m
[31m-    assert!([m
[31m-        general_shr::<i32, i32, i64>(-2147483648, 31).unwrap(),[m
[31m-        1);[m
[31m-[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1i32, 0i32).unwrap(),[m
[32m+[m[32m        1i64);[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1i32, 31i32).unwrap(),[m
[32m+[m[32m        2147483648i64);[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_shr::<i32, i32, i64>(-2147483648i32, 31i32).unwrap(),[m
[32m+[m[32m        -1i64);[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_shr::<i32,i32,i64>(1i32,0i32),[m
[32m+[m[32m        Ok(1i64));[m
[32m+[m[32m    // truth table[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_bitand::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[32m+[m[32m        Ok(0b1u64));[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_bitor::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[32m+[m[32m        Ok(0b0111u64));[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_bitxor::<u32,u32,u64>(0b0011u32,0b0101u32),[m
[32m+[m[32m        Ok(0b0110u64));[m
[32m+[m[32m    assert_eq!([m
[32m+[m[32m        general_bitnot::<i32>(0b01i32),[m
[32m+[m[32m        Ok(-2i32));[m[41m   [m
 [m
 }[m
 [m
[1mdiff --git a/src/frontend/src/expr/type_inference.rs b/src/frontend/src/expr/type_inference.rs[m
[1mindex 51b7fbd39..55a72ed42 100644[m
[1m--- a/src/frontend/src/expr/type_inference.rs[m
[1m+++ b/src/frontend/src/expr/type_inference.rs[m
[36m@@ -551,6 +551,34 @@[m [mmod tests {[m
         }[m
     }[m
 [m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn test_bitwise(){[m
[32m+[m[32m        use DataType::*;[m
[32m+[m[32m        let bitwise_exprs = vec![[m
[32m+[m[32m            ExprType::BitwiseAnd,[m
[32m+[m[32m            ExprType::BitwiseNot,[m
[32m+[m[32m            ExprType::BitwiseXor,[m
[32m+[m[32m            ExprType::PgBitwiseShiftLeft,[m
[32m+[m[32m            ExprType::PgBitwiseShiftRight,[m
[32m+[m[32m        ];[m
[32m+[m[32m        let num_promote_table = vec![[m
[32m+[m[32m            (Int16, Int16, Int16),[m
[32m+[m[32m            (Int16, Int32, Int32),[m
[32m+[m[32m            (Int16, Int64, Int64),[m
[32m+[m[32m            (Int32, Int16, Int32),[m
[32m+[m[32m            (Int32, Int32, Int32),[m
[32m+[m[32m            (Int32, Int64, Int64),[m
[32m+[m[32m            (Int64, Int16, Int64),[m
[32m+[m[32m            (Int64, Int32, Int64),[m
[32m+[m[32m            (Int64, Int64, Int64),[m
[32m+[m[41m           [m
[32m+[m[41m            [m
[32m+[m[41m            [m
[32m+[m[32m        ];[m
[32m+[m[32m        for (expr, (t1, t2, tr)) in iproduct!(bitwise_exprs, num_promote_table) {[m
[32m+[m[32m            test_simple_infer_type(expr, vec![t1, t2], tr);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
     #[test][m
     fn test_bool_num_not_exist() {[m
         let exprs = vec![[m

[33mcommit bd5b20c42f628b4931172b61ab597fbf8c825f7f[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Sat May 28 09:46:52 2022 +0800

    Done Unit testing, and done code e2e test

[1mdiff --git a/src/expr/src/vector_op/tests.rs b/src/expr/src/vector_op/tests.rs[m
[1mindex c793cac29..92c131bb4 100644[m
[1m--- a/src/expr/src/vector_op/tests.rs[m
[1m+++ b/src/expr/src/vector_op/tests.rs[m
[36m@@ -142,9 +142,23 @@[m [mfn test_bitwise() {[m
         general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
         1);[m
     [m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1, 1).unwrap(),[m
[32m+[m[32m        2);[m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1, 31).unwrap(),[m
[32m+[m[32m        -2147483648);[m
[32m+[m
     assert!([m
         general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
         1);[m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1, 1).unwrap(),[m
[32m+[m[32m        2);[m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shr::<i32, i32, i64>(-2147483648, 31).unwrap(),[m
[32m+[m[32m        1);[m
[32m+[m
 [m
 }[m
 [m

[33mcommit 375af89bcd54958adafe8cb56667ae4380ed9580[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Wed May 25 23:34:54 2022 +0800

    Bitwise not done implemetation. TODO Testing

[1mdiff --git a/src/expr/src/expr/expr_unary.rs b/src/expr/src/expr/expr_unary.rs[m
[1mindex 271fdae98..8bfc92ec8 100644[m
[1m--- a/src/expr/src/expr/expr_unary.rs[m
[1m+++ b/src/expr/src/expr/expr_unary.rs[m
[36m@@ -196,8 +196,8 @@[m [mmacro_rules! gen_unary_atm_expr  {[m
             { int16, int16, $general_func },[m
             { int32, int32, $general_func },[m
             { int64, int64, $general_func },[m
[31m-            // { float32, float32, $general_func },[m
[31m-            // { float64, float64, $general_func },[m
[32m+[m[32m            { float32, float32, $general_func },[m
[32m+[m[32m            { float64, float64, $general_func },[m
             $([m
                 { $input, $rt, $func },[m
             )*[m
[36m@@ -281,10 +281,12 @@[m [mpub fn new_unary_expr([m
             }[m
         }[m
         (ProstType::BitwiseNot, _, _) => {[m
[31m-            gen_unary_atm_expr! { "Bitwisenot", child_expr, return_type, general_bitnot,[m
[31m-                {[m
[32m+[m[32m            gen_unary_impl!{[m[41m [m
[32m+[m[32m                [ "Bitwisenot", child_expr, return_type],[m
[32m+[m[32m                { int16, int16, general_bitnot },[m
[32m+[m[32m                { int32, int32, general_bitnot },[m
[32m+[m[32m                { int64, int64, general_bitnot },[m
 [m
[31m-                }[m
             }[m
         }[m
         (expr, ret, child) => {[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex a21a61f7a..d6c521395 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -74,7 +74,7 @@[m [mwhere[m
     atm(l, r)[m
 }[m
 [m
[31m-// TODO Select an error message for bitand[m
[32m+[m[41m[m
 #[inline(always)][m
 pub fn general_bitand<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
 where[m
[1mdiff --git a/src/expr/src/vector_op/tests.rs b/src/expr/src/vector_op/tests.rs[m
[1mindex 77174522c..c793cac29 100644[m
[1m--- a/src/expr/src/vector_op/tests.rs[m
[1m+++ b/src/expr/src/vector_op/tests.rs[m
[36m@@ -136,6 +136,18 @@[m [mfn test_arithmetic() {[m
     );[m
 }[m
 [m
[32m+[m[32m#[test][m
[32m+[m[32mfn test_bitwise() {[m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
[32m+[m[32m        1);[m
[32m+[m[41m    [m
[32m+[m[32m    assert!([m
[32m+[m[32m        general_shl::<i32, i32, i64>(1, 0).unwrap(),[m
[32m+[m[32m        1);[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
 #[test][m
 fn test_comparison() {[m
     assert!(general_eq::<Decimal, i32, Decimal>(Decimal::from_str("1.0").unwrap(), 1).unwrap());[m
[1mdiff --git a/src/frontend/src/expr/function_call.rs b/src/frontend/src/expr/function_call.rs[m
[1mindex a9ea15afb..1b71dfc7c 100644[m
[1m--- a/src/frontend/src/expr/function_call.rs[m
[1m+++ b/src/frontend/src/expr/function_call.rs[m
[36m@@ -77,7 +77,6 @@[m [mimpl std::fmt::Debug for FunctionCall {[m
                 ExprType::BitwiseAnd => debug_binary_op(f,"&", &self.inputs),[m
                 ExprType::BitwiseOr => debug_binary_op(f,"|", &self.inputs),[m
                 ExprType::BitwiseXor => debug_binary_op(f,"#", &self.inputs),[m
[31m-                ExprType::BitwiseNot => debug_binary_op(f,"~",&self.inputs),[m
                 _ => {[m
                     let func_name = format!("{:?}", self.func_type);[m
                     let mut builder = f.debug_tuple(&func_name);[m

[33mcommit 74cac0f3ef3e436bc3a56a303b2af1f725a6131d[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Wed May 25 12:24:16 2022 +0800

    Edit Bitwise not But still have server closed unexpected error

[1mdiff --git a/src/expr/src/expr/expr_unary.rs b/src/expr/src/expr/expr_unary.rs[m
[1mindex 22a57448a..271fdae98 100644[m
[1m--- a/src/expr/src/expr/expr_unary.rs[m
[1m+++ b/src/expr/src/expr/expr_unary.rs[m
[36m@@ -34,6 +34,7 @@[m [muse crate::vector_op::ltrim::ltrim;[m
 use crate::vector_op::rtrim::rtrim;[m
 use crate::vector_op::trim::trim;[m
 use crate::vector_op::upper::upper;[m
[32m+[m[32muse crate::vector_op::bitwise_op::general_bitnot;[m
 [m
 /// This macro helps to create cast expression.[m
 /// It receives all the combinations of `gen_cast` and generates corresponding match cases[m
[36m@@ -195,8 +196,8 @@[m [mmacro_rules! gen_unary_atm_expr  {[m
             { int16, int16, $general_func },[m
             { int32, int32, $general_func },[m
             { int64, int64, $general_func },[m
[31m-            { float32, float32, $general_func },[m
[31m-            { float64, float64, $general_func },[m
[32m+[m[32m            // { float32, float32, $general_func },[m
[32m+[m[32m            // { float64, float64, $general_func },[m
             $([m
                 { $input, $rt, $func },[m
             )*[m
[36m@@ -279,6 +280,13 @@[m [mpub fn new_unary_expr([m
                 }[m
             }[m
         }[m
[32m+[m[32m        (ProstType::BitwiseNot, _, _) => {[m
[32m+[m[32m            gen_unary_atm_expr! { "Bitwisenot", child_expr, return_type, general_bitnot,[m
[32m+[m[32m                {[m
[32m+[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
         (expr, ret, child) => {[m
             return Err(ErrorCode::NotImplemented(format!([m
                 "The expression {:?}({:?}) ->{:?} using vectorized expression framework is not supported yet.",[m
[1mdiff --git a/src/expr/src/expr/mod.rs b/src/expr/src/expr/mod.rs[m
[1mindex 1491ddc1d..22ee1c948 100644[m
[1m--- a/src/expr/src/expr/mod.rs[m
[1m+++ b/src/expr/src/expr/mod.rs[m
[36m@@ -76,7 +76,7 @@[m [mpub fn build_from_prost(prost: &ExprNode) -> Result<BoxedExpression> {[m
 [m
     match prost.get_expr_type()? {[m
         Cast | Upper | Lower | Not | IsTrue | IsNotTrue | IsFalse | IsNotFalse | IsNull[m
[31m-        | IsNotNull | Neg | Ascii | Abs => build_unary_expr_prost(prost),[m
[32m+[m[32m        | IsNotNull | Neg | Ascii | Abs | BitwiseNot => build_unary_expr_prost(prost),[m
         Equal | NotEqual | LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Add[m
         | Subtract | Multiply | Divide | Modulus | Extract | RoundDigit | TumbleStart[m
         | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd | BitwiseOr | BitwiseXor => build_binary_expr_prost(prost),[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex 2dbea6a54..a21a61f7a 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -14,12 +14,11 @@[m
 use std::any::type_name;[m
 use std::convert::TryInto;[m
 use std::fmt::Debug;[m
[31m-use std::ops::{BitAnd, BitOr, BitXor};[m
[32m+[m[32muse std::ops::{BitAnd, BitOr, BitXor, Not};[m[41m[m
 [m
 use num_traits::{CheckedShl,CheckedShr};[m
 use risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange};[m
 use risingwave_common::error::{Result, RwError};[m
[31m-use risingwave_common::types::{IntervalUnit, NaiveDateTimeWrapper, NaiveDateWrapper};[m
 [m
 [m
 use crate::vector_op::arithmetic_op::general_atm;[m
[36m@@ -104,4 +103,11 @@[m [mwhere[m
     T3: BitXor<Output = T3>,[m
 {[m
     general_atm(l, r,  |a, b| Ok( a.bitxor(b)) )[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m}[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m#[inline(always)][m[41m[m
[32m+[m[32mpub fn general_bitnot<T1: Not<Output = T1>>(expr: T1) -> Result<T1> {[m[41m[m
[32m+[m[32m    Ok(expr.not())[m[41m[m
[32m+[m[32m}[m[41m[m
[41m+[m
[1mdiff --git a/src/frontend/src/binder/expr/binary_op.rs b/src/frontend/src/binder/expr/binary_op.rs[m
[1mindex 0b8d2d627..575326373 100644[m
[1m--- a/src/frontend/src/binder/expr/binary_op.rs[m
[1m+++ b/src/frontend/src/binder/expr/binary_op.rs[m
[36m@@ -45,7 +45,6 @@[m [mimpl Binder {[m
             BinaryOperator::NotLike => return self.bind_not_like(bound_left, bound_right),[m
             BinaryOperator::BitwiseOr => ExprType::BitwiseOr,[m
             BinaryOperator::BitwiseAnd => ExprType::BitwiseAnd,[m
[31m-            BinaryOperator::PGRegexMatch => ExprType::BitwiseNot,[m
             BinaryOperator::PGBitwiseXor => ExprType::BitwiseXor,[m
             BinaryOperator::PGBitwiseShiftLeft => ExprType::PgBitwiseShiftLeft,[m
             BinaryOperator::PGBitwiseShiftRight => ExprType::PgBitwiseShiftRight,[m
[1mdiff --git a/src/frontend/src/binder/expr/mod.rs b/src/frontend/src/binder/expr/mod.rs[m
[1mindex 0565cc52c..eef8d7512 100644[m
[1m--- a/src/frontend/src/binder/expr/mod.rs[m
[1m+++ b/src/frontend/src/binder/expr/mod.rs[m
[36m@@ -179,9 +179,10 @@[m [mimpl Binder {[m
         let func_type = match op {[m
             UnaryOperator::Not => ExprType::Not,[m
             UnaryOperator::Minus => ExprType::Neg,[m
[32m+[m[32m            UnaryOperator::PGBitwiseNot => ExprType::BitwiseNot,[m
             UnaryOperator::Plus => {[m
                 return self.rewrite_positive(expr);[m
[31m-            }[m
[32m+[m[32m            },[m
             _ => {[m
                 return Err(ErrorCode::NotImplemented([m
                     format!("unsupported unary expression: {:?}", op),[m
[1mdiff --git a/src/frontend/src/expr/type_inference.rs b/src/frontend/src/expr/type_inference.rs[m
[1mindex 7135477ca..51b7fbd39 100644[m
[1m--- a/src/frontend/src/expr/type_inference.rs[m
[1m+++ b/src/frontend/src/expr/type_inference.rs[m
[36m@@ -248,6 +248,11 @@[m [mfn build_type_derive_map() -> HashMap<FuncSign, DataTypeName> {[m
         &[E::PgBitwiseShiftLeft, E::PgBitwiseShiftRight, E::BitwiseAnd, E::BitwiseOr, E::BitwiseNot, E::BitwiseXor],[m
         &[T::Int16, T::Int32, T::Int64],[m
     );[m
[32m+[m[32m    build_unary_atm_funcs([m
[32m+[m[32m        &mut map,[m
[32m+[m[32m        &[E::BitwiseNot],[m
[32m+[m[32m        &[T::Int16, T::Int32, T::Int64],[m
[32m+[m[32m    );[m
     // temporal expressions[m
     for (base, delta) in [[m
         (T::Date, T::Int32),[m

[33mcommit 7e95f1845a2b2d7d17f0a623225916e21b91b969[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Tue May 24 01:57:09 2022 +0800

    Done implementation for bitwise and or XOR(#), TODO ~ and Unit Test and e2e test

[1mdiff --git a/proto/expr.proto b/proto/expr.proto[m
[1mindex 7ab39a6ed..b1853cee8 100644[m
[1m--- a/proto/expr.proto[m
[1m+++ b/proto/expr.proto[m
[36m@@ -33,7 +33,7 @@[m [mmessage ExprNode {[m
     BitwiseAnd = 31;[m
     BitwiseOr = 32;[m
     BitwiseXor = 33;[m
[31m-    PGBitwiseXor = 34;[m
[32m+[m[32m    BitwiseNot = 34;[m
     PGBitwiseShiftLeft = 35;[m
     PGBitwiseShiftRight = 36;[m
     // date functions[m
[1mdiff --git a/src/expr/src/expr/expr_binary_nonnull.rs b/src/expr/src/expr/expr_binary_nonnull.rs[m
[1mindex 8b3da0589..7fbf5d9e9 100644[m
[1m--- a/src/expr/src/expr/expr_binary_nonnull.rs[m
[1m+++ b/src/expr/src/expr/expr_binary_nonnull.rs[m
[36m@@ -411,6 +411,33 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         },[m
[32m+[m[32m        Type::BitwiseOr => {[m
[32m+[m[32m            gen_binary_expr_shift! {[m
[32m+[m[32m                gen_atm_impl,[m
[32m+[m[32m                l, r, ret,[m
[32m+[m[32m                general_bitor,[m
[32m+[m[32m                {[m
[32m+[m[32m                },[m
[32m+[m[32m            }[m
[32m+[m[32m        },[m
[32m+[m[32m        Type::BitwiseXor => {[m
[32m+[m[32m            gen_binary_expr_shift! {[m
[32m+[m[32m                gen_atm_impl,[m
[32m+[m[32m                l, r, ret,[m
[32m+[m[32m                general_bitxor,[m
[32m+[m[32m                {[m
[32m+[m[32m                },[m
[32m+[m[32m            }[m
[32m+[m[32m        },[m
[32m+[m[32m        // Type::Bitwisenot => {[m
[32m+[m[32m        //     gen_binary_expr_shift! {[m
[32m+[m[32m        //         gen_atm_impl,[m
[32m+[m[32m        //         l, ret,[m
[32m+[m[32m        //         general_bitnot,[m
[32m+[m[32m        //         {[m
[32m+[m[32m        //         },[m
[32m+[m[32m        //     }[m
[32m+[m[32m        // },[m
         Type::Extract => build_extract_expr(ret, l, r),[m
         Type::RoundDigit => Box::new([m
             BinaryExpression::<DecimalArray, I32Array, DecimalArray, _>::new([m
[1mdiff --git a/src/expr/src/expr/mod.rs b/src/expr/src/expr/mod.rs[m
[1mindex 7afe559c3..1491ddc1d 100644[m
[1m--- a/src/expr/src/expr/mod.rs[m
[1m+++ b/src/expr/src/expr/mod.rs[m
[36m@@ -79,7 +79,7 @@[m [mpub fn build_from_prost(prost: &ExprNode) -> Result<BoxedExpression> {[m
         | IsNotNull | Neg | Ascii | Abs => build_unary_expr_prost(prost),[m
         Equal | NotEqual | LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Add[m
         | Subtract | Multiply | Divide | Modulus | Extract | RoundDigit | TumbleStart[m
[31m-        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd => build_binary_expr_prost(prost),[m
[32m+[m[32m        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd | BitwiseOr | BitwiseXor => build_binary_expr_prost(prost),[m
         And | Or => build_nullable_binary_expr_prost(prost),[m
         Coalesce => CoalesceExpression::try_from(prost).map(|d| Box::new(d) as BoxedExpression),[m
         Substr => build_substr_expr(prost),[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex 7467f767a..2dbea6a54 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -14,7 +14,7 @@[m
 use std::any::type_name;[m
 use std::convert::TryInto;[m
 use std::fmt::Debug;[m
[31m-use std::ops::{BitAnd};[m
[32m+[m[32muse std::ops::{BitAnd, BitOr, BitXor};[m[41m[m
 [m
 use num_traits::{CheckedShl,CheckedShr};[m
 use risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange};[m
[36m@@ -81,52 +81,27 @@[m [mpub fn general_bitand<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
 where[m
     T1: TryInto<T3> + Debug,[m
     T2: TryInto<T3> + Debug,[m
[31m-    T3: BitAnd,[m
[32m+[m[32m    T3: BitAnd<Output = T3>,[m[41m[m
 {[m
[31m-    general_atm(l, r,  |a, b|  a.bitand(b)[m
[31m-        //Some(c) => Ok(c),[m
[31m-        //None => Err(RwError::from(InternalError(String::from("Unknown Error")))),[m
[31m-    )[m
[32m+[m[32m    general_atm(l, r,  |a, b| Ok( a.bitand(b)) )[m[41m[m
 }[m
 [m
[32m+[m[32m#[inline(always)][m[41m[m
[32m+[m[32mpub fn general_bitor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32mwhere[m[41m[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T3: BitOr<Output = T3>,[m[41m[m
[32m+[m[32m{[m[41m[m
[32m+[m[32m    general_atm(l, r,  |a, b| Ok( a.bitor(b)) )[m[41m[m
[32m+[m[32m}[m[41m[m
 [m
[31m-// #[inline(always)][m
[31m-// pub fn general_bitor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-// where[m
[31m-//     T1: TryInto<T3> + Debug,[m
[31m-//     T2: TryInto<T3> + Debug,[m
[31m-//     T3: CheckedShr,[m
[31m-// {[m
[31m-//     general_atm(l, r, |a, b| match a.checked_shr(b) {[m
[31m-//         Some(c) => Ok(c),[m
[31m-//         None => Err(RwError::from(NumericValueOutOfRange)),[m
[31m-//     })[m
[31m-// }[m
[31m-[m
[31m-[m
[31m-// #[inline(always)][m
[31m-// pub fn general_bitxor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-// where[m
[31m-//     T1: TryInto<T3> + Debug,[m
[31m-//     T2: TryInto<T3> + Debug,[m
[31m-// {[m
[31m-//     general_shift(l, r, |a, b| match a.checked_shr(b) {[m
[31m-//         Some(c) => Ok(c),[m
[31m-//         None => Err(RwError::from(NumericValueOutOfRange)),[m
[31m-//     })[m
[31m-// }[m
[31m-[m
[31m-[m
[31m-[m
[31m-// #[inline(always)][m
[31m-// pub fn general_bitnot<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[31m-// where[m
[31m-//     T1: TryInto<T3> + Debug,[m
[31m-//     T2: TryInto<u32> + Debug,[m
[31m-//     T3: CheckedShr,[m
[31m-// {[m
[31m-//     general_shift(l, r, |a, b| match a.checked_shr(b) {[m
[31m-//         Some(c) => Ok(c),[m
[31m-//         None => Err(RwError::from(NumericValueOutOfRange)),[m
[31m-//     })[m
[31m-// }[m
[32m+[m[32m#[inline(always)][m[41m[m
[32m+[m[32mpub fn general_bitxor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32mwhere[m[41m[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T3: BitXor<Output = T3>,[m[41m[m
[32m+[m[32m{[m[41m[m
[32m+[m[32m    general_atm(l, r,  |a, b| Ok( a.bitxor(b)) )[m[41m[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/src/frontend/src/binder/expr/binary_op.rs b/src/frontend/src/binder/expr/binary_op.rs[m
[1mindex 76765ef26..0b8d2d627 100644[m
[1m--- a/src/frontend/src/binder/expr/binary_op.rs[m
[1m+++ b/src/frontend/src/binder/expr/binary_op.rs[m
[36m@@ -45,10 +45,11 @@[m [mimpl Binder {[m
             BinaryOperator::NotLike => return self.bind_not_like(bound_left, bound_right),[m
             BinaryOperator::BitwiseOr => ExprType::BitwiseOr,[m
             BinaryOperator::BitwiseAnd => ExprType::BitwiseAnd,[m
[31m-            BinaryOperator::BitwiseXor => ExprType::BitwiseXor,[m
[31m-            BinaryOperator::PGBitwiseXor => ExprType::PgBitwiseXor,[m
[32m+[m[32m            BinaryOperator::PGRegexMatch => ExprType::BitwiseNot,[m
[32m+[m[32m            BinaryOperator::PGBitwiseXor => ExprType::BitwiseXor,[m
             BinaryOperator::PGBitwiseShiftLeft => ExprType::PgBitwiseShiftLeft,[m
             BinaryOperator::PGBitwiseShiftRight => ExprType::PgBitwiseShiftRight,[m
[32m+[m[41m            [m
             _ => return Err(ErrorCode::NotImplemented(format!("{:?}", op), 112.into()).into()),[m
         };[m
         Ok(FunctionCall::new(func_type, vec![bound_left, bound_right])?.into())[m
[1mdiff --git a/src/frontend/src/expr/function_call.rs b/src/frontend/src/expr/function_call.rs[m
[1mindex 8d0c840a7..a9ea15afb 100644[m
[1m--- a/src/frontend/src/expr/function_call.rs[m
[1m+++ b/src/frontend/src/expr/function_call.rs[m
[36m@@ -74,6 +74,10 @@[m [mimpl std::fmt::Debug for FunctionCall {[m
                 ExprType::Or => debug_binary_op(f, "OR", &self.inputs),[m
                 ExprType::PgBitwiseShiftLeft => debug_binary_op(f, "<<", &self.inputs),[m
                 ExprType::PgBitwiseShiftRight => debug_binary_op(f,">>", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseAnd => debug_binary_op(f,"&", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseOr => debug_binary_op(f,"|", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseXor => debug_binary_op(f,"#", &self.inputs),[m
[32m+[m[32m                ExprType::BitwiseNot => debug_binary_op(f,"~",&self.inputs),[m
                 _ => {[m
                     let func_name = format!("{:?}", self.func_type);[m
                     let mut builder = f.debug_tuple(&func_name);[m
[1mdiff --git a/src/frontend/src/expr/type_inference.rs b/src/frontend/src/expr/type_inference.rs[m
[1mindex b386e3721..7135477ca 100644[m
[1m--- a/src/frontend/src/expr/type_inference.rs[m
[1m+++ b/src/frontend/src/expr/type_inference.rs[m
[36m@@ -242,10 +242,10 @@[m [mfn build_type_derive_map() -> HashMap<FuncSign, DataTypeName> {[m
         FuncSign::new(E::RoundDigit, vec![T::Decimal, T::Int32]),[m
         T::Decimal,[m
     );[m
[31m-    // build bitwise operator[m
[32m+[m[32m    // bitwise operator[m
     build_binary_atm_funcs([m
         &mut map,[m
[31m-        &[E::PgBitwiseShiftLeft, E::PgBitwiseShiftRight],[m
[32m+[m[32m        &[E::PgBitwiseShiftLeft, E::PgBitwiseShiftRight, E::BitwiseAnd, E::BitwiseOr, E::BitwiseNot, E::BitwiseXor],[m
         &[T::Int16, T::Int32, T::Int64],[m
     );[m
     // temporal expressions[m

[33mcommit ed7bf1fdb5e992cee6c157ed2245455329eacfb2[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Mon May 23 21:59:40 2022 +0800

    Trying to add bitand but facing problem

[1mdiff --git a/src/expr/src/expr/expr_binary_nonnull.rs b/src/expr/src/expr/expr_binary_nonnull.rs[m
[1mindex cd2c93d88..8b3da0589 100644[m
[1m--- a/src/expr/src/expr/expr_binary_nonnull.rs[m
[1m+++ b/src/expr/src/expr/expr_binary_nonnull.rs[m
[36m@@ -197,39 +197,73 @@[m [mmacro_rules! gen_binary_expr_atm {[m
             { int16, int16, int16, $general_f },[m
             { int16, int32, int32, $general_f },[m
             { int16, int64, int64, $general_f },[m
[31m-            //{ int16, float32, float64, $general_f },[m
[31m-            //{ int16, float64, float64, $general_f },[m
[32m+[m[32m            { int16, float32, float64, $general_f },[m
[32m+[m[32m            { int16, float64, float64, $general_f },[m
[32m+[m[32m            { int32, int16, int32, $general_f },[m
[32m+[m[32m            { int32, int32, int32, $general_f },[m
[32m+[m[32m            { int32, int64, int64, $general_f },[m
[32m+[m[32m            { int32, float32, float64, $general_f },[m
[32m+[m[32m            { int32, float64, float64, $general_f },[m
[32m+[m[32m            { int64, int16,int64, $general_f },[m
[32m+[m[32m            { int64, int32,int64, $general_f },[m
[32m+[m[32m            { int64, int64, int64, $general_f },[m
[32m+[m[32m            { int64, float32, float64 , $general_f},[m
[32m+[m[32m            { int64, float64, float64, $general_f },[m
[32m+[m[32m            { float32, int16, float64, $general_f },[m
[32m+[m[32m            { float32, int32, float64, $general_f },[m
[32m+[m[32m            { float32, int64, float64 , $general_f},[m
[32m+[m[32m            { float32, float32, float32, $general_f },[m
[32m+[m[32m            { float32, float64, float64, $general_f },[m
[32m+[m[32m            { float64, int16, float64, $general_f },[m
[32m+[m[32m            { float64, int32, float64, $general_f },[m
[32m+[m[32m            { float64, int64, float64, $general_f },[m
[32m+[m[32m            { float64, float32, float64, $general_f },[m
[32m+[m[32m            { float64, float64, float64, $general_f },[m
[32m+[m[32m            { decimal, int16, decimal, $general_f },[m
[32m+[m[32m            { decimal, int32, decimal, $general_f },[m
[32m+[m[32m            { decimal, int64, decimal, $general_f },[m
[32m+[m[32m            { decimal, float32, decimal, $general_f },[m
[32m+[m[32m            { decimal, float64, decimal, $general_f },[m
[32m+[m[32m            { int16, decimal, decimal, $general_f },[m
[32m+[m[32m            { int32, decimal, decimal, $general_f },[m
[32m+[m[32m            { int64, decimal, decimal, $general_f },[m
[32m+[m[32m            { decimal, decimal, decimal, $general_f },[m
[32m+[m[32m            { float32, decimal, float64, $general_f },[m
[32m+[m[32m            { float64, decimal, float64, $general_f },[m
[32m+[m[32m            $([m
[32m+[m[32m                { $i1, $i2, $rt, $func },[m
[32m+[m[32m            )*[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/// `gen_binary_expr_shift` is similar to `gen_binary_expr_atm`.[m
[32m+[m[32m///  `shift` means arithmetic shift here.[m
[32m+[m[32m/// They are differentiate cuz shift operation does not support for float datatype.[m
[32m+[m[32m/// * `$general_f`: generic atm function (require a common ``TryInto`` type for two input)[m
[32m+[m[32m/// * `$i1`, `$i2`, `$rt`, `$func`: extra list passed to `$macro` directly[m
[32m+[m[32mmacro_rules! gen_binary_expr_shift {[m
[32m+[m[32m    ([m
[32m+[m[32m        $macro:ident,[m
[32m+[m[32m        $l:expr,[m
[32m+[m[32m        $r:expr,[m
[32m+[m[32m        $ret:expr,[m
[32m+[m[32m        $general_f:ident,[m
[32m+[m[32m        {[m
[32m+[m[32m            $( { $i1:ident, $i2:ident, $rt:ident, $func:ident }, )*[m
[32m+[m[32m        } $(,)?[m
[32m+[m[32m    ) => {[m
[32m+[m[32m        $macro! {[m
[32m+[m[32m            [$l, $r, $ret],[m
[32m+[m[32m            { int16, int16, int16, $general_f },[m
[32m+[m[32m            { int16, int32, int32, $general_f },[m
[32m+[m[32m            { int16, int64, int64, $general_f },[m
             { int32, int16, int32, $general_f },[m
             { int32, int32, int32, $general_f },[m
             { int32, int64, int64, $general_f },[m
[31m-            //{ int32, float32, float64, $general_f },[m
[31m-            //{ int32, float64, float64, $general_f },[m
             { int64, int16,int64, $general_f },[m
             { int64, int32,int64, $general_f },[m
             { int64, int64, int64, $general_f },[m
[31m-            //{ int64, float32, float64 , $general_f},[m
[31m-            //{ int64, float64, float64, $general_f },[m
[31m-            //{ float32, int16, float64, $general_f },[m
[31m-            //{ float32, int32, float64, $general_f },[m
[31m-            //{ float32, int64, float64 , $general_f},[m
[31m-            //{ float32, float32, float32, $general_f },[m
[31m-            //{ float32, float64, float64, $general_f },[m
[31m-            //{ float64, int16, float64, $general_f },[m
[31m-            //{ float64, int32, float64, $general_f },[m
[31m-            //{ float64, int64, float64, $general_f },[m
[31m-            //{ float64, float32, float64, $general_f },[m
[31m-            //{ float64, float64, float64, $general_f },[m
[31m-            // { decimal, int16, decimal, $general_f },[m
[31m-            // { decimal, int32, decimal, $general_f },[m
[31m-            // { decimal, int64, decimal, $general_f },[m
[31m-            //{ decimal, float32, decimal, $general_f },[m
[31m-            //{ decimal, float64, decimal, $general_f },[m
[31m-            // { int16, decimal, decimal, $general_f },[m
[31m-            // { int32, decimal, decimal, $general_f },[m
[31m-            // { int64, decimal, decimal, $general_f },[m
[31m-            // { decimal, decimal, decimal, $general_f },[m
[31m-            //{ float32, decimal, float64, $general_f },[m
[31m-            //{ float64, decimal, float64, $general_f },[m
             $([m
                 { $i1, $i2, $rt, $func },[m
             )*[m
[36m@@ -347,8 +381,9 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         }[m
[32m+[m[32m        // BitWise Operation[m
         Type::PgBitwiseShiftLeft => {[m
[31m-            gen_binary_expr_atm! {[m
[32m+[m[32m            gen_binary_expr_shift! {[m
                 gen_atm_impl,[m
                 l, r, ret,[m
                 general_shl,[m
[36m@@ -358,7 +393,7 @@[m [mpub fn new_binary_expr([m
             }[m
         }[m
         Type::PgBitwiseShiftRight =>{[m
[31m-            gen_binary_expr_atm! {[m
[32m+[m[32m            gen_binary_expr_shift! {[m
                 gen_atm_impl,[m
                 l, r, ret,[m
                 general_shr,[m
[36m@@ -367,6 +402,15 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         }[m
[32m+[m[32m        Type::BitwiseAnd => {[m
[32m+[m[32m            gen_binary_expr_shift! {[m
[32m+[m[32m                gen_atm_impl,[m
[32m+[m[32m                l, r, ret,[m
[32m+[m[32m                general_bitand,[m
[32m+[m[32m                {[m
[32m+[m[32m                },[m
[32m+[m[32m            }[m
[32m+[m[32m        },[m
         Type::Extract => build_extract_expr(ret, l, r),[m
         Type::RoundDigit => Box::new([m
             BinaryExpression::<DecimalArray, I32Array, DecimalArray, _>::new([m
[1mdiff --git a/src/expr/src/expr/mod.rs b/src/expr/src/expr/mod.rs[m
[1mindex 70b281b58..7afe559c3 100644[m
[1m--- a/src/expr/src/expr/mod.rs[m
[1m+++ b/src/expr/src/expr/mod.rs[m
[36m@@ -79,7 +79,7 @@[m [mpub fn build_from_prost(prost: &ExprNode) -> Result<BoxedExpression> {[m
         | IsNotNull | Neg | Ascii | Abs => build_unary_expr_prost(prost),[m
         Equal | NotEqual | LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Add[m
         | Subtract | Multiply | Divide | Modulus | Extract | RoundDigit | TumbleStart[m
[31m-        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight => build_binary_expr_prost(prost),[m
[32m+[m[32m        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight | BitwiseAnd => build_binary_expr_prost(prost),[m
         And | Or => build_nullable_binary_expr_prost(prost),[m
         Coalesce => CoalesceExpression::try_from(prost).map(|d| Box::new(d) as BoxedExpression),[m
         Substr => build_substr_expr(prost),[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex 1c3141c97..7467f767a 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -14,6 +14,8 @@[m
 use std::any::type_name;[m
 use std::convert::TryInto;[m
 use std::fmt::Debug;[m
[32m+[m[32muse std::ops::{BitAnd};[m[41m[m
[32m+[m[41m[m
 use num_traits::{CheckedShl,CheckedShr};[m
 use risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange};[m
 use risingwave_common::error::{Result, RwError};[m
[36m@@ -71,4 +73,60 @@[m [mwhere[m
         )))[m
     })?;[m
     atm(l, r)[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m}[m[41m[m
[32m+[m[41m[m
[32m+[m[32m// TODO Select an error message for bitand[m[41m[m
[32m+[m[32m#[inline(always)][m[41m[m
[32m+[m[32mpub fn general_bitand<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32mwhere[m[41m[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T2: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T3: BitAnd,[m[41m[m
[32m+[m[32m{[m[41m[m
[32m+[m[32m    general_atm(l, r,  |a, b|  a.bitand(b)[m[41m[m
[32m+[m[32m        //Some(c) => Ok(c),[m[41m[m
[32m+[m[32m        //None => Err(RwError::from(InternalError(String::from("Unknown Error")))),[m[41m[m
[32m+[m[32m    )[m[41m[m
[32m+[m[32m}[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m// #[inline(always)][m[41m[m
[32m+[m[32m// pub fn general_bitor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32m// where[m[41m[m
[32m+[m[32m//     T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m//     T2: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m//     T3: CheckedShr,[m[41m[m
[32m+[m[32m// {[m[41m[m
[32m+[m[32m//     general_atm(l, r, |a, b| match a.checked_shr(b) {[m[41m[m
[32m+[m[32m//         Some(c) => Ok(c),[m[41m[m
[32m+[m[32m//         None => Err(RwError::from(NumericValueOutOfRange)),[m[41m[m
[32m+[m[32m//     })[m[41m[m
[32m+[m[32m// }[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m// #[inline(always)][m[41m[m
[32m+[m[32m// pub fn general_bitxor<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32m// where[m[41m[m
[32m+[m[32m//     T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m//     T2: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m// {[m[41m[m
[32m+[m[32m//     general_shift(l, r, |a, b| match a.checked_shr(b) {[m[41m[m
[32m+[m[32m//         Some(c) => Ok(c),[m[41m[m
[32m+[m[32m//         None => Err(RwError::from(NumericValueOutOfRange)),[m[41m[m
[32m+[m[32m//     })[m[41m[m
[32m+[m[32m// }[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m// #[inline(always)][m[41m[m
[32m+[m[32m// pub fn general_bitnot<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m[41m[m
[32m+[m[32m// where[m[41m[m
[32m+[m[32m//     T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m//     T2: TryInto<u32> + Debug,[m[41m[m
[32m+[m[32m//     T3: CheckedShr,[m[41m[m
[32m+[m[32m// {[m[41m[m
[32m+[m[32m//     general_shift(l, r, |a, b| match a.checked_shr(b) {[m[41m[m
[32m+[m[32m//         Some(c) => Ok(c),[m[41m[m
[32m+[m[32m//         None => Err(RwError::from(NumericValueOutOfRange)),[m[41m[m
[32m+[m[32m//     })[m[41m[m
[32m+[m[32m// }[m[41m[m

[33mcommit 44a25db31c638a38b614277a38e73128a6b064ff[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Mon May 23 11:26:24 2022 +0800

    Working for >> and <<

[1mdiff --git a/src/expr/src/expr/mod.rs b/src/expr/src/expr/mod.rs[m
[1mindex 75b4f307e..70b281b58 100644[m
[1m--- a/src/expr/src/expr/mod.rs[m
[1m+++ b/src/expr/src/expr/mod.rs[m
[36m@@ -79,7 +79,7 @@[m [mpub fn build_from_prost(prost: &ExprNode) -> Result<BoxedExpression> {[m
         | IsNotNull | Neg | Ascii | Abs => build_unary_expr_prost(prost),[m
         Equal | NotEqual | LessThan | LessThanOrEqual | GreaterThan | GreaterThanOrEqual | Add[m
         | Subtract | Multiply | Divide | Modulus | Extract | RoundDigit | TumbleStart[m
[31m-        | Position => build_binary_expr_prost(prost),[m
[32m+[m[32m        | Position | PgBitwiseShiftLeft | PgBitwiseShiftRight => build_binary_expr_prost(prost),[m
         And | Or => build_nullable_binary_expr_prost(prost),[m
         Coalesce => CoalesceExpression::try_from(prost).map(|d| Box::new(d) as BoxedExpression),[m
         Substr => build_substr_expr(prost),[m
[1mdiff --git a/src/frontend/src/expr/type_inference.rs b/src/frontend/src/expr/type_inference.rs[m
[1mindex 1485b3a12..b386e3721 100644[m
[1m--- a/src/frontend/src/expr/type_inference.rs[m
[1m+++ b/src/frontend/src/expr/type_inference.rs[m
[36m@@ -242,7 +242,12 @@[m [mfn build_type_derive_map() -> HashMap<FuncSign, DataTypeName> {[m
         FuncSign::new(E::RoundDigit, vec![T::Decimal, T::Int32]),[m
         T::Decimal,[m
     );[m
[31m-[m
[32m+[m[32m    // build bitwise operator[m
[32m+[m[32m    build_binary_atm_funcs([m
[32m+[m[32m        &mut map,[m
[32m+[m[32m        &[E::PgBitwiseShiftLeft, E::PgBitwiseShiftRight],[m
[32m+[m[32m        &[T::Int16, T::Int32, T::Int64],[m
[32m+[m[32m    );[m
     // temporal expressions[m
     for (base, delta) in [[m
         (T::Date, T::Int32),[m

[33mcommit 08ec486d4032ac4fad94f4b407ff35f87ad91419[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Fri May 20 12:25:43 2022 +0800

    ModifeModified expr and frontend

[1mdiff --git a/proto/expr.proto b/proto/expr.proto[m
[1mindex dfc306caa..7ab39a6ed 100644[m
[1m--- a/proto/expr.proto[m
[1m+++ b/proto/expr.proto[m
[36m@@ -29,6 +29,13 @@[m [mmessage ExprNode {[m
     OR = 22;[m
     NOT = 23;[m
     IN = 24;[m
[32m+[m[32m    // bitwise operators[m
[32m+[m[32m    BitwiseAnd = 31;[m
[32m+[m[32m    BitwiseOr = 32;[m
[32m+[m[32m    BitwiseXor = 33;[m
[32m+[m[32m    PGBitwiseXor = 34;[m
[32m+[m[32m    PGBitwiseShiftLeft = 35;[m
[32m+[m[32m    PGBitwiseShiftRight = 36;[m
     // date functions[m
     EXTRACT = 101;[m
     TUMBLE_START = 103;[m
[1mdiff --git a/src/expr/src/expr/expr_binary_nonnull.rs b/src/expr/src/expr/expr_binary_nonnull.rs[m
[1mindex c3b186ab3..cd2c93d88 100644[m
[1m--- a/src/expr/src/expr/expr_binary_nonnull.rs[m
[1m+++ b/src/expr/src/expr/expr_binary_nonnull.rs[m
[36m@@ -24,6 +24,7 @@[m [muse risingwave_pb::expr::expr_node::Type;[m
 use crate::expr::template::BinaryExpression;[m
 use crate::expr::BoxedExpression;[m
 use crate::vector_op::arithmetic_op::*;[m
[32m+[m[32muse crate::vector_op::bitwise_op::*;[m
 use crate::vector_op::cmp::*;[m
 use crate::vector_op::extract::{extract_from_date, extract_from_timestamp};[m
 use crate::vector_op::like::like_default;[m
[36m@@ -196,39 +197,39 @@[m [mmacro_rules! gen_binary_expr_atm {[m
             { int16, int16, int16, $general_f },[m
             { int16, int32, int32, $general_f },[m
             { int16, int64, int64, $general_f },[m
[31m-            { int16, float32, float64, $general_f },[m
[31m-            { int16, float64, float64, $general_f },[m
[32m+[m[32m            //{ int16, float32, float64, $general_f },[m
[32m+[m[32m            //{ int16, float64, float64, $general_f },[m
             { int32, int16, int32, $general_f },[m
             { int32, int32, int32, $general_f },[m
             { int32, int64, int64, $general_f },[m
[31m-            { int32, float32, float64, $general_f },[m
[31m-            { int32, float64, float64, $general_f },[m
[32m+[m[32m            //{ int32, float32, float64, $general_f },[m
[32m+[m[32m            //{ int32, float64, float64, $general_f },[m
             { int64, int16,int64, $general_f },[m
             { int64, int32,int64, $general_f },[m
             { int64, int64, int64, $general_f },[m
[31m-            { int64, float32, float64 , $general_f},[m
[31m-            { int64, float64, float64, $general_f },[m
[31m-            { float32, int16, float64, $general_f },[m
[31m-            { float32, int32, float64, $general_f },[m
[31m-            { float32, int64, float64 , $general_f},[m
[31m-            { float32, float32, float32, $general_f },[m
[31m-            { float32, float64, float64, $general_f },[m
[31m-            { float64, int16, float64, $general_f },[m
[31m-            { float64, int32, float64, $general_f },[m
[31m-            { float64, int64, float64, $general_f },[m
[31m-            { float64, float32, float64, $general_f },[m
[31m-            { float64, float64, float64, $general_f },[m
[31m-            { decimal, int16, decimal, $general_f },[m
[31m-            { decimal, int32, decimal, $general_f },[m
[31m-            { decimal, int64, decimal, $general_f },[m
[31m-            { decimal, float32, decimal, $general_f },[m
[31m-            { decimal, float64, decimal, $general_f },[m
[31m-            { int16, decimal, decimal, $general_f },[m
[31m-            { int32, decimal, decimal, $general_f },[m
[31m-            { int64, decimal, decimal, $general_f },[m
[31m-            { decimal, decimal, decimal, $general_f },[m
[31m-            { float32, decimal, float64, $general_f },[m
[31m-            { float64, decimal, float64, $general_f },[m
[32m+[m[32m            //{ int64, float32, float64 , $general_f},[m
[32m+[m[32m            //{ int64, float64, float64, $general_f },[m
[32m+[m[32m            //{ float32, int16, float64, $general_f },[m
[32m+[m[32m            //{ float32, int32, float64, $general_f },[m
[32m+[m[32m            //{ float32, int64, float64 , $general_f},[m
[32m+[m[32m            //{ float32, float32, float32, $general_f },[m
[32m+[m[32m            //{ float32, float64, float64, $general_f },[m
[32m+[m[32m            //{ float64, int16, float64, $general_f },[m
[32m+[m[32m            //{ float64, int32, float64, $general_f },[m
[32m+[m[32m            //{ float64, int64, float64, $general_f },[m
[32m+[m[32m            //{ float64, float32, float64, $general_f },[m
[32m+[m[32m            //{ float64, float64, float64, $general_f },[m
[32m+[m[32m            // { decimal, int16, decimal, $general_f },[m
[32m+[m[32m            // { decimal, int32, decimal, $general_f },[m
[32m+[m[32m            // { decimal, int64, decimal, $general_f },[m
[32m+[m[32m            //{ decimal, float32, decimal, $general_f },[m
[32m+[m[32m            //{ decimal, float64, decimal, $general_f },[m
[32m+[m[32m            // { int16, decimal, decimal, $general_f },[m
[32m+[m[32m            // { int32, decimal, decimal, $general_f },[m
[32m+[m[32m            // { int64, decimal, decimal, $general_f },[m
[32m+[m[32m            // { decimal, decimal, decimal, $general_f },[m
[32m+[m[32m            //{ float32, decimal, float64, $general_f },[m
[32m+[m[32m            //{ float64, decimal, float64, $general_f },[m
             $([m
                 { $i1, $i2, $rt, $func },[m
             )*[m
[36m@@ -346,6 +347,26 @@[m [mpub fn new_binary_expr([m
                 },[m
             }[m
         }[m
[32m+[m[32m        Type::PgBitwiseShiftLeft => {[m
[32m+[m[32m            gen_binary_expr_atm! {[m
[32m+[m[32m                gen_atm_impl,[m
[32m+[m[32m                l, r, ret,[m
[32m+[m[32m                general_shl,[m
[32m+[m[32m                {[m
[32m+[m
[32m+[m[32m                },[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        Type::PgBitwiseShiftRight =>{[m
[32m+[m[32m            gen_binary_expr_atm! {[m
[32m+[m[32m                gen_atm_impl,[m
[32m+[m[32m                l, r, ret,[m
[32m+[m[32m                general_shr,[m
[32m+[m[32m                {[m
[32m+[m
[32m+[m[32m                },[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
         Type::Extract => build_extract_expr(ret, l, r),[m
         Type::RoundDigit => Box::new([m
             BinaryExpression::<DecimalArray, I32Array, DecimalArray, _>::new([m
[36m@@ -359,6 +380,7 @@[m [mpub fn new_binary_expr([m
             l, r, ret, position,[m
         )),[m
         Type::TumbleStart => new_tumble_start(l, r, ret),[m
[32m+[m[41m        [m
         tp => {[m
             unimplemented!([m
                 "The expression {:?} using vectorized expression framework is not supported yet!",[m
[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex 2492ea230..1c3141c97 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -11,7 +11,7 @@[m
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
 // See the License for the specific language governing permissions and[m
 // limitations under the License.[m
[31m-[m
[32m+[m[32muse std::any::type_name;[m[41m[m
 use std::convert::TryInto;[m
 use std::fmt::Debug;[m
 use num_traits::{CheckedShl,CheckedShr};[m
[36m@@ -19,17 +19,17 @@[m [muse risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange}[m
 use risingwave_common::error::{Result, RwError};[m
 use risingwave_common::types::{IntervalUnit, NaiveDateTimeWrapper, NaiveDateWrapper};[m
 [m
[31m-mod arithmetic_op;[m
[31m-use arithmetic_op::general_atm;[m
[32m+[m[41m[m
[32m+[m[32muse crate::vector_op::arithmetic_op::general_atm;[m[41m[m
 [m
 #[inline(always)][m
 pub fn general_shl<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
 where[m
     T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m[41m[m
     T3: CheckedShl,[m
 {[m
[31m-    general_atm(l, r, |a, b| match a.checked_shl(&b) {[m
[32m+[m[32m    general_shift(l, r, |a, b| match a.checked_shl(b) {[m[41m[m
         Some(c) => Ok(c),[m
         None => Err(RwError::from(NumericValueOutOfRange)),[m
     })[m
[36m@@ -39,11 +39,36 @@[m [mwhere[m
 pub fn general_shr<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
 where[m
     T1: TryInto<T3> + Debug,[m
[31m-    T2: TryInto<T3> + Debug,[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m[41m[m
     T3: CheckedShr,[m
 {[m
[31m-    general_atm(l, r, |a, b| match a.checked_shr(&b) {[m
[32m+[m[32m    general_shift(l, r, |a, b| match a.checked_shr(b) {[m[41m[m
         Some(c) => Ok(c),[m
         None => Err(RwError::from(NumericValueOutOfRange)),[m
     })[m
 }[m
[32m+[m[41m[m
[32m+[m[32m#[inline(always)][m[41m[m
[32m+[m[32mpub fn general_shift<T1, T2, T3, F>(l: T1, r: T2, atm: F) -> Result<T3>[m[41m[m
[32m+[m[32mwhere[m[41m[m
[32m+[m[32m    T1: TryInto<T3> + Debug,[m[41m[m
[32m+[m[32m    T2: TryInto<u32> + Debug,[m[41m[m
[32m+[m[32m    F: FnOnce(T3, u32) -> Result<T3>,[m[41m[m
[32m+[m[32m{[m[41m[m
[32m+[m[32m    // TODO: We need to improve the error message[m[41m[m
[32m+[m[32m    let l: T3 = l.try_into().map_err(|_| {[m[41m[m
[32m+[m[32m        RwError::from(InternalError(format!([m[41m[m
[32m+[m[32m            "Can't convert {} to {}",[m[41m[m
[32m+[m[32m            type_name::<T1>(),[m[41m[m
[32m+[m[32m            type_name::<T3>()[m[41m[m
[32m+[m[32m        )))[m[41m[m
[32m+[m[32m    })?;[m[41m[m
[32m+[m[32m    let r: u32 = r.try_into().map_err(|_| {[m[41m[m
[32m+[m[32m        RwError::from(InternalError(format!([m[41m[m
[32m+[m[32m            "Can't convert {} to {}",[m[41m[m
[32m+[m[32m            type_name::<T2>(),[m[41m[m
[32m+[m[32m            type_name::<u32>()[m[41m[m
[32m+[m[32m        )))[m[41m[m
[32m+[m[32m    })?;[m[41m[m
[32m+[m[32m    atm(l, r)[m[41m[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/src/expr/src/vector_op/mod.rs b/src/expr/src/vector_op/mod.rs[m
[1mindex 2da2d1421..648e1f31e 100644[m
[1m--- a/src/expr/src/vector_op/mod.rs[m
[1m+++ b/src/expr/src/vector_op/mod.rs[m
[36m@@ -15,6 +15,7 @@[m
 pub mod agg;[m
 pub mod arithmetic_op;[m
 pub mod ascii;[m
[32m+[m[32mpub mod bitwise_op;[m
 pub mod cast;[m
 pub mod cmp;[m
 pub mod conjunction;[m
[1mdiff --git a/src/frontend/src/binder/expr/binary_op.rs b/src/frontend/src/binder/expr/binary_op.rs[m
[1mindex 6ae6870a5..76765ef26 100644[m
[1m--- a/src/frontend/src/binder/expr/binary_op.rs[m
[1m+++ b/src/frontend/src/binder/expr/binary_op.rs[m
[36m@@ -43,12 +43,12 @@[m [mimpl Binder {[m
             BinaryOperator::Or => ExprType::Or,[m
             BinaryOperator::Like => ExprType::Like,[m
             BinaryOperator::NotLike => return self.bind_not_like(bound_left, bound_right),[m
[31m-            BinaryOperator::BitwiseOr => ExprType::BitwiseOr[m
[31m-            BinaryOperator::BitwiseAnd => ExprType::BitwiseAnd[m
[31m-            BinaryOperator::BitwiseXor => ExprType::BitwiseXor[m
[31m-            BinaryOperator::PGBitwiseXor => ExprType::PGBitwiseXor,[m
[31m-            BinaryOperator::PGBitwiseShiftLeft => ExprType::PGBitwiseShiftLeft,[m
[31m-            BinaryOperator::PGBitwiseShiftRight => ExprType::PGBitwiseShiftRight,[m
[32m+[m[32m            BinaryOperator::BitwiseOr => ExprType::BitwiseOr,[m
[32m+[m[32m            BinaryOperator::BitwiseAnd => ExprType::BitwiseAnd,[m
[32m+[m[32m            BinaryOperator::BitwiseXor => ExprType::BitwiseXor,[m
[32m+[m[32m            BinaryOperator::PGBitwiseXor => ExprType::PgBitwiseXor,[m
[32m+[m[32m            BinaryOperator::PGBitwiseShiftLeft => ExprType::PgBitwiseShiftLeft,[m
[32m+[m[32m            BinaryOperator::PGBitwiseShiftRight => ExprType::PgBitwiseShiftRight,[m
             _ => return Err(ErrorCode::NotImplemented(format!("{:?}", op), 112.into()).into()),[m
         };[m
         Ok(FunctionCall::new(func_type, vec![bound_left, bound_right])?.into())[m
[1mdiff --git a/src/frontend/src/expr/function_call.rs b/src/frontend/src/expr/function_call.rs[m
[1mindex 744e1f7ce..8d0c840a7 100644[m
[1m--- a/src/frontend/src/expr/function_call.rs[m
[1m+++ b/src/frontend/src/expr/function_call.rs[m
[36m@@ -72,7 +72,8 @@[m [mimpl std::fmt::Debug for FunctionCall {[m
                 ExprType::GreaterThanOrEqual => debug_binary_op(f, ">=", &self.inputs),[m
                 ExprType::And => debug_binary_op(f, "AND", &self.inputs),[m
                 ExprType::Or => debug_binary_op(f, "OR", &self.inputs),[m
[31m-                [m
[32m+[m[32m                ExprType::PgBitwiseShiftLeft => debug_binary_op(f, "<<", &self.inputs),[m
[32m+[m[32m                ExprType::PgBitwiseShiftRight => debug_binary_op(f,">>", &self.inputs),[m
                 _ => {[m
                     let func_name = format!("{:?}", self.func_type);[m
                     let mut builder = f.debug_tuple(&func_name);[m

[33mcommit a84172c8d38df846d62cd199ede8c5bcee191efc[m
Author: marvenlee2486 <leezongyu6878@gmail.com>
Date:   Fri May 20 00:51:57 2022 +0800

    Add ExprType and Do binding of BinaryOperator to ExprType

[1mdiff --git a/src/expr/src/vector_op/bitwise_op.rs b/src/expr/src/vector_op/bitwise_op.rs[m
[1mindex 8e4f568be..2492ea230 100644[m
[1m--- a/src/expr/src/vector_op/bitwise_op.rs[m
[1m+++ b/src/expr/src/vector_op/bitwise_op.rs[m
[36m@@ -19,7 +19,8 @@[m [muse risingwave_common::error::ErrorCode::{InternalError, NumericValueOutOfRange}[m
 use risingwave_common::error::{Result, RwError};[m
 use risingwave_common::types::{IntervalUnit, NaiveDateTimeWrapper, NaiveDateWrapper};[m
 [m
[31m-[m
[32m+[m[32mmod arithmetic_op;[m[41m[m
[32m+[m[32muse arithmetic_op::general_atm;[m[41m[m
 [m
 #[inline(always)][m
 pub fn general_shl<T1, T2, T3>(l: T1, r: T2) -> Result<T3>[m
[1mdiff --git a/src/frontend/src/binder/expr/binary_op.rs b/src/frontend/src/binder/expr/binary_op.rs[m
[1mindex b8b074634..6ae6870a5 100644[m
[1m--- a/src/frontend/src/binder/expr/binary_op.rs[m
[1m+++ b/src/frontend/src/binder/expr/binary_op.rs[m
[36m@@ -43,6 +43,12 @@[m [mimpl Binder {[m
             BinaryOperator::Or => ExprType::Or,[m
             BinaryOperator::Like => ExprType::Like,[m
             BinaryOperator::NotLike => return self.bind_not_like(bound_left, bound_right),[m
[32m+[m[32m            BinaryOperator::BitwiseOr => ExprType::BitwiseOr[m
[32m+[m[32m            BinaryOperator::BitwiseAnd => ExprType::BitwiseAnd[m
[32m+[m[32m            BinaryOperator::BitwiseXor => ExprType::BitwiseXor[m
[32m+[m[32m            BinaryOperator::PGBitwiseXor => ExprType::PGBitwiseXor,[m
[32m+[m[32m            BinaryOperator::PGBitwiseShiftLeft => ExprType::PGBitwiseShiftLeft,[m
[32m+[m[32m            BinaryOperator::PGBitwiseShiftRight => ExprType::PGBitwiseShiftRight,[m
             _ => return Err(ErrorCode::NotImplemented(format!("{:?}", op), 112.into()).into()),[m
         };[m
         Ok(FunctionCall::new(func_type, vec![bound_left, bound_right])?.into())[m
[1mdiff --git a/src/frontend/src/expr/function_call.rs b/src/frontend/src/expr/function_call.rs[m
[1mindex b6da99bdb..744e1f7ce 100644[m
[1m--- a/src/frontend/src/expr/function_call.rs[m
[1m+++ b/src/frontend/src/expr/function_call.rs[m
[36m@@ -72,6 +72,7 @@[m [mimpl std::fmt::Debug for FunctionCall {[m
                 ExprType::GreaterThanOrEqual => debug_binary_op(f, ">=", &self.inputs),[m
                 ExprType::And => debug_binary_op(f, "AND", &self.inputs),[m
                 ExprType::Or => debug_binary_op(f, "OR", &self.inputs),[m
[32m+[m[41m                [m
                 _ => {[m
                     let func_name = format!("{:?}", self.func_type);[m
                     let mut builder = f.debug_tuple(&func_name);[m
